## 模块分析

### ALU

根据CPU需要实现的指令来确定自己的ALU要做哪些操作。

比如加减运算等，

通过一个ALUop来“告诉”CPU要对输入的数干什么，然后输出。

感觉应该是最简单的了吧😣

### DM

也是难度较小的一个模块，但有以下几个思考点

1. ROM，RAM与Register的选择

内存是需要有读取和写入两个操作的，而ROM只有读取，out

在一个周期内，DM只会有读取和写入操作中的一个，因此大可不必上GRF那般的Register，加上DM空间容量也大，上GRF不够现实，因此选择**RAM**

1. 寻址

问题在于MIPS和Logisim寻址的区别的转换。MIPS地址按字寻址，而RAM是是按字节，且MIPS中的地址是32位，Logisim是5位，即MIPS中的PC+4对应的是RAM中Address+1，如果地址从0开始的话，那么MIPS中就是0， 4， 8，……，而RAM中就是0， 1， 2， ……，正好是4倍的关系，再结合二进制下有关$2^n$的倍数等同于右移，因此我们要取Address的2-6位

（或许也可以这么想，+4对应成二进制就是+100，因此第0，1位没啥影响，对序列数产生直接影响的从第2位开始）

### EXT

好吧我错了，这应该才是最简单的模块，用两个bit_extender(对应0扩展和符号扩展)，一个MUX（以EXTOp为选择信号），就愉快的搭完了

### GRF

似乎明白了P0搭GRF的奥义，搬过来照常用就好了

### IFU

内部包括 PC（程序计数器）、IM(指令存储器)及相关逻辑

- IM
    
    有之前分析可得，IM只有读取的操作，因此选用ROM足够了
    
    主要是根据PC值取指令，这边具体有两个需要注意的点
    
    1. 和DM一样，针对PC+4，取2-6位作为ROM的地址
    2. 异步复位的问题
        
        Logisim复位是复位到0x0000_0000加上地址确实也是从0x0000_0000开始的，问题不大
        
        但是，为了和MIPS有一致性，我的写法是复位到0x0000_3000，然后再统一减去3000开始
        
        这时需要一个比较器和MUX
        
       ![image](https://user-images.githubusercontent.com/95061623/150537368-124d8adb-5895-4c71-bc87-d0d4caa7e4a4.png)
        
- NPC:
    
    正常PC+4，其余可以根据指令的特殊性进行跳转，关键在于用MUX进行一次条件判断
    
  ![image](https://user-images.githubusercontent.com/95061623/150537420-383c2e06-b3dc-4998-a899-c408ab6a66f0.png)

### Controller

这个在先前的教程中已经较为完备的展现了，就是用与或门阵列判断指令，再根据每个指令所需要实现的signal进行反馈

## 一些有意思的指令设计

有意思针对的数据通路，与一些有意思的运算处理无关

### j/jal，jr

每个周期都按照RTL进行计算，再用mux判定

对于jal，可以再利用MUX对GRF进行修改

![image](https://user-images.githubusercontent.com/95061623/150537493-ed5398e8-9881-468a-8403-6b4add45d335.png)

whichtoReg决定了写入A3的内容

![image](https://user-images.githubusercontent.com/95061623/150537547-4687e8e8-4f80-4ffc-b7db-948364bda520.png)

**做到P4发现自己jr搭错了 

是自己对指令理解的问题, jr的意义应该是 `PC = GPR[rs]`  ~~我以为是`PC=GPR[31]`~~

### sb，sh/lb，lh

Key：我们得到的32位地址的2-6位可以提供内存中的某一个地址，而后0,1位可以用来判定具体地址的部分位，如sb/lb 对应的[0,7] [8,15], [16, 23], [24, 31] sh/lh对应的[0-15], [16, 31]

同时，因为sw/sh 需要再原数组基础下，挑一部分出来修改，因此我们需要对传入的选择信号选择WD的一部分和原有的数据拼接，这就需要译码器的使用，根据传入的addr的后面两位选择需要拼接的WD[7:0] 或 [15:0]

![image](https://user-images.githubusercontent.com/95061623/150537629-b8806101-4dd5-4e1c-8827-ffe055a40a0e.png)

# P3 课上

和往年类似，一个跳转一个运算一个访存

## bezal

if GPR[rs] == 0:

PC = GRF[rt]

GPR[$31] = PC+4;

else

PC = PC+4

把我杀死的一个题，因为condition写的太离谱了

可以考虑本身指令附带条件的话，再Controller结束后将两个条件利用与门更新一下，可以确保自己不会迷糊

## slo

将一个数左移并补1，看到最百花齐放的做法

看到比较多的好像是

1. 先弄出s个1，然后利用bit-extender（0扩展）弄到32位，然后将正常左移得到的数进行或运算（利用或运算保持非0值的性质）
2. 将原来的数+1，后左移s位，再扣掉1 （看到那么多1会有一个+1的想法吧哈哈哈哈）

## lwor

印象中是lw改了一点

GPR[rt] = memory[GPR[base] + offest + rt*4]

也没啥，算address加一个rt*4就好了，但确实题目讲的有点不够明白，这里的rt指的是寄存器的编号，就真的是Instr[20:16]的东西
